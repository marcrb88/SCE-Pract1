"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.defaultLogger = void 0;
exports.expressEndpoint = expressEndpoint;
exports.handleRequest = handleRequest;
exports.log = log;
var _url = _interopRequireDefault(require("url"));
var _constants = require("./constants");
const defaultLogger = {
  log(req, level, name, payload) {
    const date = payload.timestamp ? new Date(payload.timestamp).toString() : new Date().toString();
    const str = [name, "\t[ ", date, " ]\n", Object.keys(payload).map(key => {
      return `\t${key}: ${payload[key]}`;
    }).join("\n"), "\n"].join("");
    console[level](str);
  },
  track(req, tracking) {
    console.log("[track]\n", Object.keys(tracking).map(key => {
      return `\t${key}: ${tracking[key]}`;
    }).join("\n"), "\n");
  },
  metric(req, metric) {
    console.log(`[metric].${metric.name}\n`, Object.keys(metric.dimensions).map(key => {
      return `\t${key}: ${metric.dimensions[key]}`;
    }).join("\n"), "\n");
  },
  meta(req, meta) {
    console.log("[meta]\n", Object.keys(meta).map(key => {
      return `\t${key}: ${meta[key]}`;
    }).join("\n"), "\n");
  }
};
exports.defaultLogger = defaultLogger;
function log(req, logger, logs) {
  const events = logs.events || [];
  const tracking = logs.tracking || [];
  const metrics = logs.metrics || [];
  const meta = logs.meta || {};
  if (logger.meta) {
    logger.meta(req, meta);
  }
  if (logger.log) {
    events.forEach(event => {
      if (!event.event || typeof event.event !== "string") {
        return;
      }
      const name = event.event.replace(/_*[^a-zA-Z0-9_]+_*/g, "_");
      const level = event.level || _constants.LOG_LEVEL.INFO;
      const payload = event.payload || {};
      return logger.log(req, level, name, payload, meta);
    });
  }
  if (logger.track) {
    tracking.forEach(track => {
      logger.track(req, track, meta);
    });
  }
  if (logger.metric) {
    metrics.forEach(metric => {
      logger.metric(req, metric);
    });
  }
}
function handleRequest(req, logger) {
  const method = req.method || _constants.HTTP_METHOD.GET;
  const query = req.query;
  const body = req.body || {};
  if (method.toLowerCase() === "post") {
    const {
      events,
      tracking,
      metrics,
      meta
    } = body;
    log(req, logger, {
      events,
      tracking,
      metrics,
      meta
    });
  } else {
    const {
      event,
      level = _constants.LOG_LEVEL.INFO,
      ...payload
    } = query;
    log(req, logger, {
      events: [{
        level,
        event,
        payload
      }]
    });
  }
}
function sendCorsHeaders(req, res) {
  const origin = req.get(_constants.HTTP_HEADER.ORIGIN);
  if (origin) {
    const parsedUrl = _url.default.parse(origin) || {};
    if (!parsedUrl.protocol || !parsedUrl.host) {
      res.header(_constants.HTTP_HEADER.ACCESS_CONTROL_ALLOW_ORIGIN, _constants.WILDCARD);
    } else {
      res.header(_constants.HTTP_HEADER.ACCESS_CONTROL_ALLOW_ORIGIN, `${parsedUrl.protocol}//${parsedUrl.host}`);
    }
  } else {
    res.header(_constants.HTTP_HEADER.ACCESS_CONTROL_ALLOW_ORIGIN, _constants.WILDCARD);
  }
  const corsRequestHeaders = req.headers[_constants.HTTP_HEADER.ACCESS_CONTROL_REQUEST_HEADERS];
  if (corsRequestHeaders) {
    res.header(_constants.HTTP_HEADER.ACCESS_CONTROL_ALLOW_HEADERS, corsRequestHeaders);
  }
  const corsRequestMethod = req.headers[_constants.HTTP_HEADER.ACCESS_CONTROL_REQUEST_METHOD];
  if (corsRequestMethod) {
    res.header(_constants.HTTP_HEADER.ACCESS_CONTROL_ALLOW_METHODS, corsRequestMethod);
  }
  res.header(_constants.HTTP_HEADER.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
}
function expressEndpoint({
  uri = "/",
  logger = defaultLogger,
  enableCors = false
} = {}) {
  const app = require("express")();
  app.on("mount", parent => {
    app.settings = Object.create(parent.settings);
    app.kraken = parent.kraken || parent.config;
  });
  app.all(uri, (req, res) => {
    if (enableCors) {
      sendCorsHeaders(req, res);
    }
    if (req.method.toLowerCase() === _constants.HTTP_METHOD.OPTIONS) {
      return res.status(200).header(_constants.HTTP_HEADER.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true").send();
    }
    try {
      handleRequest(req, logger);
      res.status(200).header(_constants.HTTP_HEADER.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true").json({});
    } catch (err) {
      console.error(err.stack || err.toString());
      res.status(500).header(_constants.HTTP_HEADER.CONTENT_TYPE, "application/json").json({});
    }
  });
  return app;
}